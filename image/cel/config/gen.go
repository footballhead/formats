//+build ignore

// gen.go generates the data files required to decode CEL images, which specify
// the decoding algorithms, image dimensions, palettes and colour transitions of
// each CEL image.
package main

import (
	"bytes"
	"flag"
	"go/format"
	"io/ioutil"
	"log"
	"path/filepath"
	"text/template"

	"github.com/mewkiz/pkg/errutil"
	"github.com/sanctuary/formats/level/min"
)

func main() {
	var (
		// mpqDir specifies the path to an extracted "diabdat.mpq".
		mpqDir string
	)
	flag.StringVar(&mpqDir, "mpqdir", "diabdat/", `Path to extracted "diabdat.mpq".`)
	flag.Parse()

	// Parse MIN files.
	levelNames := []string{"l1", "l2", "l3", "l4", "town"}
	var mappings []*minMapping
	for _, levelName := range levelNames {
		mapping, err := parseMin(mpqDir, levelName)
		if err != nil {
			log.Fatal(err)
		}
		mappings = append(mappings, mapping)
	}

	// Generate "data.go".
	if err := genData(mappings); err != nil {
		log.Fatal(err)
	}
}

// A minMapping specifies the mapping between frame numbers and frame types of a
// given MIN file.
type minMapping struct {
	// Level name.
	LevelName string
	// frameTypes maps from frame number to frame type.
	FrameTypes []int
}

// parseMin parses the given MIN file and returns a mapping from frame numbers
// to frame types.
func parseMin(mpqDir, levelName string) (*minMapping, error) {
	// MIN path; e.g. "diabdat/levels/l1data/l1.cel".
	name := levelName + ".min"
	minPath := filepath.Join(mpqDir, "levels", levelName+"data", name)
	pieces, err := min.Parse(minPath)
	if err != nil {
		return nil, errutil.Err(err)
	}
	// m maps from frame numbers to frame types.
	m := make(map[int]int)
	for _, piece := range pieces {
		for _, block := range piece.Blocks {
			m[block.FrameNum] = block.FrameType
		}
	}
	mapping := &minMapping{
		LevelName:  levelName,
		FrameTypes: make([]int, len(m)),
	}
	for frameNum, frameType := range m {
		mapping.FrameTypes[frameNum] = frameType
	}
	return mapping, nil
}

// genData generates the data files required to decode CEL images, which specify
// the decoding algorithms, image dimensions, palettes and colour transitions of
// each CEL image.
func genData(mappings []*minMapping) error {
	t := template.New("data")
	if _, err := t.Parse(dataContent[1:]); err != nil {
		return errutil.Err(err)
	}
	buf := new(bytes.Buffer)
	if err := t.Execute(buf, mappings); err != nil {
		return errutil.Err(err)
	}
	data, err := format.Source(buf.Bytes())
	if err != nil {
		return errutil.Err(err)
	}
	if err := ioutil.WriteFile("data.go", data, 0644); err != nil {
		return errutil.Err(err)
	}
	return nil
}

const dataContent = `
// generated by gen.go using 'go generate'; DO NOT EDIT.

package config

import "path/filepath"

// Mappings from frame numbers to frame types for each of the level CEL files
// "l1.cel", "l2.cel", "l3.cel", "l4.cel" and "town.cel".
var (
{{- range . }}
	{{ .LevelName }}FrameTypes = {{ printf "%#v" .FrameTypes }}
{{- end }}
)

// getDecoderType returns the CEL frame decoder type of to the given file name
// and frame number.
func getDecoderType(name string, frameNum int) int {
	if filepath.Ext(name) == ".cl2" {
		// Return default CL2 decoder (ref: cel.decodeType6).
		return 6
	}

	// Determine level CEL frame decoder based on the MIN frame type mappings.
	switch name {
	case "l1.cel":
		return l1FrameTypes[frameNum]
	case "l2.cel":
		return l2FrameTypes[frameNum]
	case "l3.cel":
		return l3FrameTypes[frameNum]
	case "l4.cel":
		return l4FrameTypes[frameNum]
	case "town.cel":
		return townFrameTypes[frameNum]
	}

	// Return default CEL decoder (ref: cel.decodeType1).
	return 1
}
`
